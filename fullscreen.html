<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EFPlus Graph</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    #error {
      color: red;
      font-family: sans-serif;
      padding: 20px;
    }
  </style>
</head>
<body>
  <canvas id="efp-social-graph-canvas"></canvas>
  <div id="error" style="display: none;"></div>

  <script>
   (function () {
    const canvas = document.getElementById("efp-social-graph-canvas")
    const ctx = canvas.getContext("2d")

    function resizeCanvas() {
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
    }
    window.addEventListener("resize", resizeCanvas)
    resizeCanvas()

    const params = new URLSearchParams(location.search)
    const address = params.get("address")
    const ensName = params.get("ens")
    const avatarUrl = params.get("avatar")

    if (!address) {
      showError("Invalid Listid")
      return
    }

    fetch(`https://api.ethfollow.xyz/api/v1/lists/${address}/followers?sort=followers&limit=2000`)
      .then(res => {
        if (!res.ok) throw new Error("No Data")
        return res.json()
      })
      .then(data => {
        const followers = data.followers || []
        renderSocialGraph(canvas, address, followers, { ensName, avatarUrl })
      })
      .catch(err => {
        showError("Failed to loadï¼š" + err.message)
      })

    function showError(msg) {
      document.getElementById("error").innerText = msg
      document.getElementById("error").style.display = "block"
    }

	  // æ¸²æŸ“ç¤¾äº¤å›¾è°±å¯è§†åŒ–
	  function renderSocialGraph(canvas, centralAddress, followers, userInfo) {  
		const ctx = canvas.getContext("2d")
		const width = canvas.width
		const height = canvas.height

		// ä¸­å¿ƒç‚¹åæ ‡
		const centerX = width / 2
		const centerY = height / 2

		// æ¸…é™¤ç”»å¸ƒ
		ctx.clearRect(0, 0, width, height)

		// ç»˜åˆ¶èƒŒæ™¯
		ctx.fillStyle = "rgba(10, 10, 30, 0.8)"
		ctx.fillRect(0, 0, width, height)

		// é¢„åŠ è½½ç”¨æˆ·å¤´åƒ
		const avatarImage = new Image()
		avatarImage.crossOrigin = "anonymous" // é¿å…CORSé—®é¢˜

		// è®¾ç½®é»˜è®¤å¤´åƒï¼Œä»¥é˜²åŠ è½½å¤±è´¥
		let avatarLoaded = false

		// å¦‚æœæœ‰å¤´åƒURLï¼Œåˆ™åŠ è½½å¤´åƒ
		if (userInfo.avatarUrl) {
		  avatarImage.onload = () => {
			avatarLoaded = true
			// å¤´åƒåŠ è½½å®Œæˆåé‡ç»˜ä¸­å¿ƒèŠ‚ç‚¹
			drawCenterNode()
		  }
		  avatarImage.onerror = () => {
			drawCenterNode()
		  }
		  avatarImage.src = userInfo.avatarUrl
		}
		
		let rotationAngle = 0  // å…¨å±€å˜é‡

		// ç»˜åˆ¶ä¸­å¿ƒèŠ‚ç‚¹çš„å‡½æ•°
		function drawCenterNode() {
		  // ä¸­å¿ƒèŠ‚ç‚¹åŠå¾„å¢å¤§
		  const centerNodeRadius = 40
		  
		  // ä¿å­˜åŸå§‹çŠ¶æ€
		  ctx.save()
		  
		  // å¹³ç§»åˆ°ä¸­å¿ƒï¼Œç„¶åæ—‹è½¬
		  ctx.translate(centerX, centerY)
		  ctx.rotate(rotationAngle)
		  ctx.translate(-centerX, -centerY)
		  
		  const pulseRadius = centerNodeRadius + 10 + Math.sin(Date.now() / 300) * 5

		  // ç»˜åˆ¶ä¸­å¿ƒèŠ‚ç‚¹èƒŒæ™¯
		  ctx.beginPath()
		  ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2)
		  ctx.strokeStyle = "rgba(255, 255, 255, 0.2)"
		  ctx.lineWidth = 2
		  ctx.stroke()

		  // å¦‚æœå¤´åƒå·²åŠ è½½ï¼Œåˆ™ç»˜åˆ¶å¤´åƒ
		  if (avatarLoaded) {
			// åˆ›å»ºåœ†å½¢è£å‰ªåŒºåŸŸ
			ctx.save()
			ctx.beginPath()
			ctx.arc(centerX, centerY, centerNodeRadius - 2, 0, Math.PI * 2)
			ctx.clip()

			// ç»˜åˆ¶å¤´åƒ
			ctx.drawImage(
			  avatarImage,
			  centerX - (centerNodeRadius - 2),
			  centerY - (centerNodeRadius - 2),
			  (centerNodeRadius - 2) * 2,
			  (centerNodeRadius - 2) * 2,
			)
			ctx.restore()
		  }
		  
		  // æ¢å¤æ—‹è½¬çŠ¶æ€
		  ctx.restore()

		  // æ·»åŠ ç”¨æˆ·åç§°æ–‡æœ¬ï¼ˆä½¿ç”¨ENSæˆ–åœ°å€ï¼‰
		  ctx.font = "bold 16px Arial"
		  ctx.fillStyle = "#ffffff"
		  ctx.textAlign = "center"

		  // ä¼˜å…ˆä½¿ç”¨ENSåç§°ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨ç¼©çŸ­çš„åœ°å€
		  const displayName = userInfo.ensName || shortenAddress(centralAddress)
		  ctx.fillText(displayName, centerX, centerY + centerNodeRadius + 25)
		}

		// åˆå§‹ç»˜åˆ¶ä¸­å¿ƒèŠ‚ç‚¹
		drawCenterNode()

		// åˆå§‹åŒ–æµæ˜Ÿ - ä»æœ€å·¦ä¾§å’Œæœ€å³ä¾§å‘ä¸­å¿ƒå‘å°„
		const stars = []

		// æµæ˜Ÿè½¨é“
		followers.slice(0, 2000).forEach((follower, index) => {
		  const angle = Math.random() * Math.PI * 2
		  const minRadius = 120
		  const radiusStep = 0.8 // æ¯ä¸ª follower é—´éš”å¤šå°‘è·ç¦»
		  const jitter = (Math.random() - 0.5) * 2 // [-1, +1] èŒƒå›´æŠ–åŠ¨
		  const radius = minRadius + index * radiusStep + jitter
		  const angularSpeed = 0.002 + Math.random() * 0.003 // æ§åˆ¶æ—‹è½¬é€Ÿåº¦

		  stars.push({
			follower,
			angle,
			radius,
			angularSpeed,
			size: Math.random() * 3 + 1.5,
			color: getRandomColor(),
		  })
		})

		// åŠ¨ç”»å‡½æ•°
		function animate() {
		  // æ¯å¸§é€’å¢æ—‹è½¬è§’åº¦ï¼ˆå¦‚æœä½ æœªæ¥æƒ³è®©ä¸­å¿ƒèŠ‚ç‚¹æ—‹è½¬ï¼‰
		  rotationAngle += 0.005

		  // æ¸…é™¤ç”»å¸ƒ
		  ctx.clearRect(0, 0, width, height)

		  // ç»˜åˆ¶èƒŒæ™¯
		  ctx.fillStyle = "rgba(10, 10, 30, 0.8)"
		  ctx.fillRect(0, 0, width, height)

		  // ==== ğŸŒŒ ç»˜åˆ¶æ¯ä¸ªç¯ç»•æµæ˜Ÿ ====
		  stars.forEach((star, index) => {
			star.angle += star.angularSpeed
			const angle = star.angle
			const x = centerX + Math.cos(angle) * star.radius
			const y = centerY + Math.sin(angle) * star.radius

			// ===== ğŸŒŸ å°¾å·´è½¨è¿¹ï¼ˆæ²¿åæ–¹å‘æ‹‰å‡ºï¼‰ =====
			const tailX = centerX + Math.cos(angle - 0.2) * star.radius
			const tailY = centerY + Math.sin(angle - 0.2) * star.radius

			const alpha = 0.6 + 0.4 * Math.sin(Date.now() / 200 + index)

			const trailGradient = ctx.createLinearGradient(x, y, tailX, tailY)
			trailGradient.addColorStop(0, hexToRgba(star.color, alpha))
			trailGradient.addColorStop(1, hexToRgba(star.color, 0))

			ctx.beginPath()
			ctx.moveTo(x, y)
			ctx.lineTo(tailX, tailY)
			ctx.strokeStyle = trailGradient
			ctx.lineWidth = star.size
			ctx.stroke()

			// ==== â­ æ˜Ÿæ˜Ÿä¸»ä½“ ====
			ctx.beginPath()
			ctx.arc(x, y, star.size, 0, Math.PI * 2)
			ctx.fillStyle = hexToRgba(star.color, alpha)
			ctx.fill()

			// ==== ğŸ‘¤ åå­—æ ‡ç­¾é è¿‘ä¸­å¿ƒæ‰æ˜¾ç¤º ====
			if (star.radius < 350) {
			  ctx.font = "12px Arial"
			  ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`
			  ctx.textAlign = "center"
			  ctx.fillText(star.follower.efp_list_nft_token_id, x, y - 10)
			} else {
			  ctx.font = "6px Arial"
			  ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`
			  ctx.textAlign = "center"
			  ctx.fillText(star.follower.efp_list_nft_token_id, x, y - 10)		  
			}
		  })

		  // ==== ğŸª é‡ç»˜ä¸­å¿ƒèŠ‚ç‚¹ ====
		  drawCenterNode()

		  // è¯·æ±‚ä¸‹ä¸€å¸§
		  requestAnimationFrame(animate)
		}

		// å¼€å§‹åŠ¨ç”»
		animate()
	  }
	  
	  // è¾…åŠ©å‡½æ•°ï¼šæ˜Ÿæ˜Ÿé—ªçƒ
		function hexToRgba(hex, alpha) {
		  const bigint = parseInt(hex.replace("#", ""), 16)
		  const r = (bigint >> 16) & 255
		  const g = (bigint >> 8) & 255
		  const b = bigint & 255
		  return `rgba(${r}, ${g}, ${b}, ${alpha})`
		}

	  // è¾…åŠ©å‡½æ•°ï¼šç¼©çŸ­ä»¥å¤ªåŠåœ°å€
	  function shortenAddress(address) {
		if (!address) return ""
		return address.substring(0, 6) + "..." + address.substring(address.length - 4)
	  }

	  // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆéšæœºé¢œè‰²
	  function getRandomColor() {
		const colors = [
		  "#FF6B6B",
		  "#4ECDC4",
		  "#FFD166",
		  "#06D6A0",
		  "#118AB2",
		  "#EF476F",
		  "#FFC43D",
		  "#1B9AAA",
		  "#6A4C93",
		  "#F72585",
		]
		return colors[Math.floor(Math.random() * colors.length)]
	  }
	})()
  </script>
</body>
</html>
